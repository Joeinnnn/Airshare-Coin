<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Live Pump.fun Tracker</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0e1116;
      --fg: #e6edf3;
      --panel: #0b1220;
      --border: #1f2a3a;
      --muted: #93a4b7;
      --brand: #58a6ff;   /* professional blue */
      --accent: #238636;  /* success green */
      --accent2: #58a6ff; /* secondary */
      --header-gradient: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(0,0,0,0.07));
      --success: #2ea043;
      --scroll-track: #0b1220;
      --scroll-thumb: #203047;
      --card-radius: 12px;
    }
    body[data-theme="light"] {
      --bg: #f7f9fc;
      --fg: #172136;
      --panel: #ffffff;
      --border: #e5ecf6;
      --muted: #51627a;
      --brand: #2b63ff;
      --success: #0cb37a;
    }
    body { margin:0; background: var(--bg); color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    /* CRT scanlines */
    body::after { content:""; position:fixed; inset:0; pointer-events:none; background:
      repeating-linear-gradient(0deg, rgba(255,255,255,.04), rgba(255,255,255,.04) 1px, transparent 1px, transparent 3px);
      mix-blend-mode: overlay; opacity:.08; }
    /* Neon grid */
    body::before { content:""; position:fixed; inset:0; pointer-events:none; background:
      radial-gradient(1200px 800px at 50% -20%, rgba(34,197,94,0.08), transparent),
      radial-gradient(1200px 800px at 50% 120%, rgba(88,166,255,0.05), transparent),
      repeating-linear-gradient(0deg, transparent 0 22px, rgba(34,197,94,0.07) 23px),
      repeating-linear-gradient(90deg, transparent 0 22px, rgba(34,197,94,0.07) 23px);
      animation: gridMove 22s linear infinite; opacity:.35; }
    @keyframes gridMove { from { background-position: 0 0, 0 0, 0 0, 0 0; } to { background-position: 0 0, 0 0, 0 44px, 44px 0; } }
    .wrap { max-width: 1200px; margin: 0 auto; padding: 24px; }
    header { display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; background:transparent; border:0; border-radius: var(--card-radius); padding:8px 0; }
    .brand { font-weight:800; font-size:20px; color:var(--brand); letter-spacing:.2px; }
    .mint { font-size:13px; color:var(--muted); word-break:break-all; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .btn { padding:8px 12px; background:var(--accent); color:#fff; border:1px solid #1f6f3a; border-radius:8px; cursor:pointer; text-decoration:none; display:inline-block; transition: filter .15s ease, opacity .2s; box-shadow: 0 0 0 2px #0a141f inset, 0 0 12px rgba(34,197,94,.15); font-family: 'Press Start 2P', system-ui; font-size:11px; letter-spacing:.08em; }
    .btn:hover { filter: brightness(1.05); }
    .btn:active { transform: translateY(1px); }
    .btn:disabled { opacity:.6; cursor:default; }
    .hero { margin:18px 0; background:var(--panel); border:1px solid var(--border); border-radius: var(--card-radius); padding:12px; position:relative; overflow:hidden; }
    .hero:before { content:""; position:absolute; inset:0; background:
      repeating-linear-gradient(0deg, rgba(255,255,255,0.03), rgba(255,255,255,0.03) 1px, transparent 1px, transparent 3px),
      radial-gradient(800px 200px at 30% -20%, rgba(34,197,94,0.09), transparent),
      radial-gradient(800px 200px at 70% 120%, rgba(34,197,94,0.06), transparent);
      pointer-events:none; }
    .hud { display:grid; grid-template-columns: repeat(3, 1fr); gap:12px; position:relative; z-index:1; }
    .hud-card { border:1px solid var(--border); border-radius:10px; background:#0a141f; padding:10px 12px; box-shadow: 0 0 0 1px #183046 inset, 0 0 18px rgba(34,197,94,.08); }
    .hud-card .label { font-family: 'Press Start 2P', system-ui; font-size:10px; color:#7aa6ff; letter-spacing:.15em; text-transform:uppercase; opacity:.9; }
    .hud-card .value { font-family: 'Share Tech Mono', ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:26px; color:#8fffba; text-shadow: 0 0 6px rgba(34,197,94,.6), 0 0 18px rgba(34,197,94,.2); margin-top:6px; }
    .cap { font-size:30px; font-weight:900; font-family: 'Share Tech Mono', ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; padding:0; border-radius:0; background:transparent; border:0; color:#8fffba; letter-spacing:1px; text-shadow: 0 0 6px rgba(34,197,94,.6), 0 0 18px rgba(34,197,94,.2); transition: transform .2s ease, text-shadow .2s ease; }
    .cap.cap-animate { transform: translateY(-1px); text-shadow: 0 0 10px rgba(34,197,94,.8), 0 0 26px rgba(34,197,94,.35); }
    .chip { display:inline-block; padding:4px 8px; border-radius:6px; background:#0a141f; color:#7aa6ff; border:1px solid #183046; font-size:12px; font-family: 'Press Start 2P', system-ui; letter-spacing:.1em; }
    .latest { margin:12px 0; padding:14px; border:1px solid var(--border); border-radius: var(--card-radius); background:var(--panel); display:flex; align-items:center; gap:12px; min-height:108px; position:relative; }
    .latest.pulse { animation: latestPulse 900ms ease-out; }
    @keyframes latestPulse { 0% { box-shadow: 0 0 0 rgba(34,197,94,0.0); border-color: var(--border);} 30% { box-shadow: 0 0 24px rgba(34,197,94,0.35); border-color: #2ea043;} 100% { box-shadow: 0 0 0 rgba(34,197,94,0.0); border-color: var(--border);} }
    .notice { font-size:12px; color:var(--muted); margin-top:6px; }
    .latest .text { font-size:22px; color:var(--success); font-weight:800; }
    .cols { display:grid; grid-template-columns: 1fr 1fr; gap:16px; align-items:start; }
    @media (max-width: 800px) { .cols { grid-template-columns: 1fr; } }
    .panel { background:var(--panel); border:1px solid var(--border); border-radius: var(--card-radius); overflow:hidden; }
    .panel h3 { margin:0; padding:10px 12px; font-size:12px; color:#7aa6ff; border-bottom:1px solid var(--border); text-transform: uppercase; letter-spacing:.18em; font-family: 'Press Start 2P', system-ui; }
    .panel .body { padding:12px 14px; font-family: 'Share Tech Mono', ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:15px; line-height:1.5; white-space:pre-wrap; }
    .panel .body.scroll { max-height: 420px; overflow: auto; }
    .panel .body.scroll { max-height: 420px; overflow: auto; }
    .list { list-style:none; margin:0; padding:0; }
    .list li { padding:9px 12px; border-bottom:1px solid var(--border); font-family: 'Share Tech Mono', ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color:#b8d7c6; letter-spacing:.02em; }
    .list li:hover { background:#0e1520; }
    .small { font-size:12px; opacity:.85; }
    a { color: var(--brand); }

    /* Scrollbar: match page, hide arrows */
    * { scrollbar-width: thin; scrollbar-color: var(--scroll-thumb) var(--scroll-track); }
    ::-webkit-scrollbar { width: 10px; height: 10px; }
    ::-webkit-scrollbar-track { background: var(--scroll-track); }
    ::-webkit-scrollbar-thumb { background: var(--scroll-thumb); border-radius: 8px; border: 2px solid var(--scroll-track); }
    ::-webkit-scrollbar-button { width: 0; height: 0; display: none; }

    /* airdrop visual effects */
    .airdrop-flash { animation: airdropFlash 800ms ease-out; }
    @keyframes airdropFlash { 0% { box-shadow: 0 0 0 rgba(88,166,255,0); border-color: var(--border);} 50% { box-shadow: 0 0 26px rgba(88,166,255,.35); border-color: #58a6ff;} 100% { box-shadow: 0 0 0 rgba(88,166,255,0); border-color: var(--border);} }
    .win-animate { animation: winGlow 1200ms ease-out; }
    @keyframes winGlow { 0% { box-shadow: 0 0 0 rgba(88,166,255,0); } 40% { box-shadow: 0 0 26px rgba(88,166,255,.35); } 100% { box-shadow: 0 0 0 rgba(88,166,255,0); } }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="controls">
        <a id="pumpLink" class="btn" href="https://pump.fun" target="_blank" rel="noopener">Open on Pump.fun</a>
        <a id="xBtn" class="btn" href="https://x.com/i/communities/1970111571679715570" target="_blank" rel="noopener">X Community</a>
        <button id="shareTopBtn" class="btn" type="button">Share Top Buyers (PNG)</button>
      </div>
      <div class="mint" id="mint" style="margin-left:auto;">Mint: â€”</div>
    </header>

    <section class="hero">
      <div class="hud">
        <div class="hud-card">
          <div class="label">Market Cap</div>
          <div class="value" id="cap">Market Cap: N/A</div>
        </div>
        <div class="hud-card">
          <div class="label">Trades</div>
          <div class="value" id="tradesCount">0</div>
        </div>
        <div class="hud-card">
          <div class="label">Airdrop</div>
          <div class="value" id="airdropCountdown">â€”</div>
        </div>
      </div>
    </section>

    <section class="latest" id="latest" style="position:relative;">
      <div class="text" id="latestText">Waiting for buysâ€¦</div>
      <canvas id="confetti" style="position:absolute; inset:0; pointer-events:none;"></canvas>
    </section>
    <!-- fullscreen FX canvas for bursts -->
    <canvas id="fxCanvas" style="position:fixed; inset:0; pointer-events:none; z-index:5;"></canvas>
    <div class="notice">* GIF popup shows only buys â‰¥ 0.1 SOL. The page may briefly switch views while syncing.</div>
    <div class="notice">* Only buyers with â‰¥0.1 SOL buys will show your username and GIF.</div>

    <section class="cols">
      <div class="panel">
        <h3>Leaderboard</h3>
        <div class="body scroll" id="topbuyers"></div>
        <div class="small" id="topTraderLine" style="padding:8px 12px;">Top Trader: â€”</div>
      </div>
      <div class="panel">
        <h3>Airdrop</h3>
        <div class="body">
          <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
            <div id="airdropStatus">Airdrop: â€”</div>
            <div class="airdrop-actions">
              <button id="airdropNowBtn" class="btn" type="button">Airdrop Now</button>
            </div>
          </div>
          <div class="small" style="margin:6px 0 10px 0;">Ends when countdown hits 0. You can also end now.</div>
          <div id="winners" class="scroll" style="margin-top:10px; white-space:pre-wrap;"></div>
        </div>
      </div>
    </section>

    <section class="cols" style="margin-top:16px;">
      <div class="panel">
        <h3>Recent Buys</h3>
        <ul class="list" id="recent"></ul>
      </div>
      <div class="panel">
        <h3>Latest Transaction</h3>
        <div class="body">
          <a id="txLink" href="#" target="_blank" rel="noopener" style="word-break:break-all; color:var(--brand); text-decoration:underline;">â€”</a>
          <div class="small">Most recent buy signature. Click to view on Solscan.</div>
        </div>
      </div>
    </section>

    
  </div>

  <!-- Process steps moved out for a cleaner look -->

  

  <script>
    // globals must be defined before use to avoid TDZ errors
    var lastCap = '';
    var pollTimer = null;
    var lastTopRaw = '';
    var lastTxHash = '';
    var lastTopJsonRaw = '';
    window.__lastWsMs = 0;
    window.__lastShownLine = '';
    // Allow external data root override: /?dataRoot=https://data.example.com
    const DATA_ROOT = new URLSearchParams(location.search).get('dataRoot') || '';
    const SOUND_ENABLED = false; // disable kaching sound
    // html2canvas for PNG export
    (function(){
      const s = document.createElement('script');
      s.src = 'https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js';
      s.defer = true; document.head.appendChild(s);
    })();
    const wsUrl = 'wss://pumpportal.fun/api/data';
    let ws = null; // declare persistent WS handle
    let currentMint = '';
    // Aggregate by wallet address; store display name per address
    const buyerStats = new Map(); // address -> { name, count, total }
    let trades = 0;
    const TOP_BUYERS_LIMIT = 50; // show up to 50 instead of 10

    // fixed site: mint comes from coin.txt

    function shorten(addr) {
      if (!addr) return 'User';
      return addr.length > 10 ? addr.slice(0,4) + 'â€¦' + addr.slice(-4) : addr;
    }

    function updateTop() {
      // Client-side computed Top Buyers no longer used to avoid mismatch.
      // Rendering handled by server file in the poll below.
    }

    const seenLines = new Set();
    function addRecent(line) {
      if (!line || seenLines.has(line)) return;
      seenLines.add(line);
      const ul = document.getElementById('recent');
      const li = document.createElement('li');
      li.textContent = line;
      li.style.cursor = 'pointer';
      li.addEventListener('click', () => showBuyerDetailsFromLine(line));
      ul.prepend(li);
      while (ul.children.length > 20) ul.removeChild(ul.lastChild);
    }
    function showBuyerDetailsFromLine(line){
      // extract display name from "<who> Bought <amt> SOL"
      const m = line.match(/^(.*)\s+Bought\s+([0-9.]+)\s+SOL/i);
      if (!m) return;
      const who = m[1].trim();
      showBuyerDetails(who);
    }
    function showBuyerDetails(displayName){
      const arr = loadHistory(currentMint || 'fallback');
      const seenS = new Set();
      const items = [];
      for (let i = arr.length - 1; i >= 0 && items.length < 20; i--) {
        const e = arr[i];
        if (!e || !e.sig) continue; // only WS-confirmed
        if (seenS.has(e.sig)) continue;
        if ((e.name || e.addr) !== displayName) continue;
        seenS.add(e.sig); items.push(e);
      }
      const total = items.reduce((s,e)=> s + (Number(e.amount)||0), 0);
      alert(`${displayName}\nTrades: ${items.length}\nTotal: ${total.toFixed(4)} SOL\n\nRecent:\n` + items.map(e=>`â€¢ ${e.amount} SOL`).join('\n'));
    }

    // ---- Persistent history (per mint) using localStorage ----
    function historyKey(mint){ return 'pf_history_' + mint; }
    function loadHistory(mint){
      try { return JSON.parse(localStorage.getItem(historyKey(mint)) || '[]'); } catch { return []; }
    }
    function saveHistory(mint, arr){
      try { localStorage.setItem(historyKey(mint), JSON.stringify(arr.slice(-500))); } catch {}
    }
    // Track processed trade signatures to avoid double-counting across refreshes
    function seenKey(mint){ return 'pf_seen_' + mint; }
    function loadSeen(mint){
      try { return new Set(JSON.parse(localStorage.getItem(seenKey(mint)) || '[]')); } catch { return new Set(); }
    }
    function saveSeen(mint, seen){
      try { localStorage.setItem(seenKey(mint), JSON.stringify(Array.from(seen).slice(-2000))); } catch {}
    }
    function renderHistory(mint){
      const arr = loadHistory(mint);
      const ul = document.getElementById('recent');
      ul.innerHTML = '';
      // Only reflect unique, WS-confirmed trades (with signature)
      const seenS = new Set();
      const unique = [];
      for (const e of arr) {
        if (!e || !e.sig) continue;
        if (seenS.has(e.sig)) continue;
        seenS.add(e.sig); unique.push(e);
      }
      unique.slice(-50).reverse().forEach(e => addRecent(`${e.name || shorten(e.addr)} Bought ${e.amount} SOL`));
      // rebuild top buyers and trades count from history
      buyerStats.clear(); trades = 0;
      for (const e of unique){
        const addr = e.addr || '';
        const s = buyerStats.get(addr) || { name: e.name || shorten(addr), count:0, total:0 };
        s.count += 1; s.total += Number(e.amount)||0; buyerStats.set(addr, s);
        trades += 1;
      }
      document.getElementById('tradesCount').textContent = String(trades);
      updateTop();
    }

    // Update header market cap from WS when provided; file-poll remains as fallback
    function setCapFromMsg(msg){
      const capSol = Number(msg && msg.marketCapSol);
      if (isFinite(capSol) && capSol > 0){
        const cap = `$${(capSol * 100).toFixed(1)}K`;
        lastCap = 'Market Cap: ' + cap;
        document.getElementById('cap').textContent = lastCap;
      }
    }

    function connect(mint) {
      if (ws) try { ws.close(); } catch(_) {}
      try { if (ws) ws.close(); } catch(_) {}
      ws = new WebSocket(wsUrl);
      ws.addEventListener('open', () => {
        // subscribe to both variants (with and without trailing 'pump')
        const mintNoSuffix = mint.replace(/pump$/i, '');
        const keys = Array.from(new Set([mint, mintNoSuffix].filter(Boolean)));
        const payload = { method: 'subscribeTokenTrade', keys };
        ws.send(JSON.stringify(payload));
        document.getElementById('mint').textContent = 'Mint: ' + mint;
        document.getElementById('pumpLink').href = 'https://pump.fun/coin/' + mint;
        // Render any stored history for this mint immediately
        renderHistory(mint);
      });
      ws.addEventListener('message', (ev) => {
        try {
          const raw = JSON.parse(ev.data);
          if (raw.message) return; // subscription ack
          const data = raw.trade || raw || {};
          setCapFromMsg(data);
          const tx = String(data.txType || data.type || data.side || '').toLowerCase();
          const isBuy = data.isBuy === true || tx === 'buy';
          if (!isBuy) return;
          const mm = String(data.mint || data.token || data.ca || '');
          if (!(mm === mint || mm === mint.replace(/pump$/i, ''))) return;
          const username = (data.user && (data.user.name || data.user.username)) || data.username || data.name;
          const addr = String(data.traderPublicKey || data.buyer || data.account || '');
          const who = username || shorten(addr);
          const amount = Number(data.solAmount ?? data.sol ?? data.amount ?? data.size ?? 0);
          // Signature-based dedupe BEFORE updating counts
          const seen = loadSeen(mint);
          const sig = String(raw.signature || data.signature || data.sig || `${mm}:${addr}:${amount}`);
          if (seen.has(sig)) return;
          const isWhale = amount >= 1; // threshold for whale/confetti
          const line = `${isWhale ? 'ðŸ³ ' : ''}${who} Bought ${amount} SOL`;
          trades += 1;
          document.getElementById('tradesCount').textContent = String(trades);
          // GIF popup only for buys >= 0.1 SOL and skip duplicate banner
          const GIF_MIN_SOL = 0.1;
          if (amount >= GIF_MIN_SOL && window.__lastShownLine !== line) {
            document.getElementById('latestText').textContent = line;
            // effect: pulse outline + confetti for whales
            const latest = document.getElementById('latest');
            latest.classList.remove('pulse');
            void latest.offsetWidth; // restart animation
            latest.classList.add('pulse');
            if (isWhale) triggerConfetti();
            // particle burst
            try { particleBurst(); } catch(_) {}
            window.__lastShownLine = line;
            // after 3s, return to standby text
            setTimeout(()=>{ document.getElementById('latestText').textContent='Waiting for buysâ€¦'; }, 3000);
          }
          addRecent(line);
          const s = buyerStats.get(addr) || { name: who, count:0, total:0 };
          s.name = s.name || who;
          s.count += 1; s.total += amount; buyerStats.set(addr, s);
          updateTop();

          // persist with signature-based dedupe to avoid count growth on refresh
          const arr = loadHistory(mint);
          if (!seen.has(sig)){
            arr.push({ ts: Date.now(), addr, name: who, amount, sig });
            saveHistory(mint, arr);
            seen.add(sig);
            saveSeen(mint, seen);
          }
          window.__lastWsMs = Date.now();
        } catch(e) { console.warn('parse/ws error', e); }
          // banner reset handled above only when shown
      });
    }

    function applyMint(mint){
      if (!mint) return;
      const prev = localStorage.getItem('pf_current_mint');
      if (prev !== mint) {
        try { Object.keys(localStorage).forEach(k => { if (k.startsWith('pf_history_') || k.startsWith('pf_seen_')) localStorage.removeItem(k); }); } catch {}
        document.getElementById('recent').innerHTML = '';
        document.getElementById('topbuyers').textContent = '';
        document.getElementById('tradesCount').textContent = '0';
        seenLines.clear(); buyerStats.clear(); trades = 0; lastPolledTrade = '';
      }
      localStorage.setItem('pf_current_mint', mint);
      currentMint = mint;
      try { document.getElementById('pumpLink').href = 'https://pump.fun/coin/' + mint; } catch(_) {}
      try { document.getElementById('mint').textContent = 'Mint: ' + mint; } catch(_) {}
      if (prev !== mint) connect(mint);
    }

    // Fixed: auto-connect to coin from coin.txt on load
    (function boot(){
      // force dark theme and clear old toggle state
      try { document.body.removeAttribute('data-theme'); localStorage.removeItem('pf_theme'); } catch {}
      // fixed theme â€” no dynamic accent
      try { localStorage.removeItem('pf_color1'); } catch {}

      fetchText('coin.txt')
        .then(txt => (txt || '').trim())
        .then(applyMint);

      // Re-check coin.txt every 5s in case the tracker switches coins (migration or manual change)
      setInterval(() => {
        fetchText('coin.txt')
          .then(txt => (txt || '').trim())
          .then(applyMint)
          .catch(()=>{});
      }, 5000);
    })();

    // removed accent picker; fixed palette
    function triggerConfetti(){
      const canvas = document.getElementById('confetti');
      const ctx = canvas.getContext('2d');
      const box = canvas.parentElement.getBoundingClientRect();
      canvas.width = box.width; canvas.height = box.height;
      const pieces = Array.from({length: 120}).map(()=>({
        x: Math.random()*canvas.width,
        y: -10,
        s: 2+Math.random()*4,
        c: Math.random()<0.5? getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() : getComputedStyle(document.documentElement).getPropertyValue('--accent2').trim(),
        v: 1+Math.random()*2,
        a: Math.random()*Math.PI*2
      }));
      let t = 0; const maxT = 900; // ~1.2s
      function step(){
        ctx.clearRect(0,0,canvas.width,canvas.height);
        pieces.forEach(p=>{ p.y += p.v; p.x += Math.sin(p.a+=0.05); ctx.fillStyle=p.c; ctx.fillRect(p.x,p.y,p.s,p.s); });
        t+=16; if (t<maxT) requestAnimationFrame(step); else ctx.clearRect(0,0,canvas.width,canvas.height);
      }
      requestAnimationFrame(step);
    }
    function particleBurst(){
      const canvas = document.getElementById('fxCanvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const { innerWidth: W, innerHeight: H } = window;
      canvas.width = W; canvas.height = H;
      const cx = W * 0.5, cy = H * 0.25;
      const parts = Array.from({length: 80}).map(()=>({
        x: cx, y: cy,
        vx: (Math.random()-0.5) * 6,
        vy: (Math.random()-0.5) * 4 - 2,
        life: 700 + Math.random()*400,
        size: 2 + Math.random()*3,
        hue: Math.random() < 0.5 ? 140 : 210
      }));
      let start = performance.now();
      function frame(t){
        const dt = 16; // approx
        ctx.clearRect(0,0,W,H);
        parts.forEach(p=>{
          p.x += p.vx; p.y += p.vy; p.vy += 0.05; p.life -= dt;
          ctx.fillStyle = `hsla(${p.hue}, 80%, 60%, ${Math.max(0, p.life/1000)})`;
          ctx.fillRect(p.x, p.y, p.size, p.size);
        });
        if (performance.now() - start < 900) requestAnimationFrame(frame); else ctx.clearRect(0,0,W,H);
      }
      requestAnimationFrame(frame);
    }
    function applyAccent(c1) {
      const c2 = generateSiblingColor(c1);
      document.documentElement.style.setProperty('--accent', c1);
      document.documentElement.style.setProperty('--accent2', c2);
      document.documentElement.style.setProperty('--accent-gradient', `linear-gradient(90deg, ${c1}, ${c2})`);
      document.documentElement.style.setProperty('--header-gradient', `linear-gradient(90deg, ${c1}22, ${c2}22)`);
      // tint the entire page using the accent
      const baseBg = '#0b0f14';
      const basePanel = '#0e1621';
      const baseBorder = '#1f2a3a';
      document.documentElement.style.setProperty('--bg', mix(baseBg, c1, 0.12));
      document.documentElement.style.setProperty('--panel', mix(basePanel, c1, 0.10));
      document.documentElement.style.setProperty('--border', mix(baseBorder, c1, 0.35));
      document.documentElement.style.setProperty('--brand', c1);
      try { localStorage.setItem('pf_color1', c1); } catch {}
    }

    // Share Top Buyers as PNG
    document.getElementById('shareTopBtn').addEventListener('click', async () => {
      if (!(window.html2canvas)) {
        return alert('Preparing export library... try again in a second.');
      }
      const panel = document.getElementById('topbuyers');
      if (!panel || !panel.textContent.trim()) {
        return alert('No Top Buyers to export yet.');
      }
      try {
        // Wrap in a styled container to ensure nice background
        const wrapper = document.createElement('div');
        wrapper.style.background = getComputedStyle(document.body).getPropertyValue('--panel') || '#0e1621';
        wrapper.style.color = getComputedStyle(document.body).getPropertyValue('--fg') || '#e8f0f8';
        wrapper.style.padding = '12px';
        wrapper.style.border = '1px solid ' + (getComputedStyle(document.body).getPropertyValue('--border') || '#1f2a3a');
        const title = document.createElement('div');
        title.textContent = 'Top Buyers';
        title.style.fontWeight = '700';
        title.style.marginBottom = '6px';
        title.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
        wrapper.appendChild(title);
        const clone = panel.cloneNode(true);
        clone.style.maxWidth = '640px';
        clone.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
        wrapper.appendChild(clone);
        document.body.appendChild(wrapper);
        const canvas = await html2canvas(wrapper, {backgroundColor: null, scale: 2});
        document.body.removeChild(wrapper);
        const link = document.createElement('a');
        link.download = 'topbuyers.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
      } catch(e) {
        console.error(e);
        alert('Export failed.');
      }
    });
    try { if (accentPicker) accentPicker.addEventListener('input', (e)=> applyAccent(e.target.value)); } catch(_) {}

    // --- Fallback polling for market cap (and optional text mirrors) ---
    async function fetchText(file){
      try {
        const base = DATA_ROOT ? DATA_ROOT.replace(/\/$/, '') + '/' : '';
        const res = await fetch(base + file + '?t=' + Date.now(), { cache: 'no-store' });
        if (!res.ok) return '';
        return await res.text();
      } catch { return ''; }
    }
    // Keep a memory of the last polled trade to avoid duplicates
    let lastPolledTrade = '';
    pollTimer = setInterval(async () => {
      // Market Cap from local tracker (if running)
      try {
        const cap = (await fetchText('marketcap.txt')).trim();
        if (cap) {
          lastCap = cap;
          const capEl = document.getElementById('cap');
          capEl.textContent = cap;
          capEl.classList.remove('cap-animate'); void capEl.offsetWidth; capEl.classList.add('cap-animate');
        } else if (lastCap) {
          document.getElementById('cap').textContent = lastCap;
        } else {
          document.getElementById('cap').textContent = 'Market Cap: N/A';
        }
      } catch(_) {
        if (!lastCap) document.getElementById('cap').textContent = 'Market Cap: N/A';
      }

      // Latest transaction hash (always poll)
      try {
        const tx = (await fetchText('txhash.txt')).trim();
        const link = document.getElementById('txLink');
        if (tx && tx !== lastTxHash) {
          lastTxHash = tx;
          link.textContent = tx;
          link.href = 'https://solscan.io/tx/' + encodeURIComponent(tx);
        } else if (!tx && !lastTxHash) {
          link.textContent = 'â€”';
          link.removeAttribute('href');
        }
      } catch(_) {}

      // Recent buy fallback: only if no WS trades in the last 7s (avoid duplicate popup during lag)
      const wsMs = window.__lastWsMs || 0;
      const now = Date.now();
      const allowFallback = (now - wsMs) >= 7000;
      if (!allowFallback) return;
      // read latest line from trades.txt and append to history
      try {
        const latest = (await fetchText('trades.txt')).trim();
        if (latest && latest !== lastPolledTrade) {
          lastPolledTrade = latest;
          // show banner only if >= 0.1 SOL and not shown already
          const m = latest.match(/^(.*)\s+Bought\s+([0-9.]+)\s+SOL/i);
          const GIF_MIN_SOL = 0.1;
          if (m) {
            const who = m[1].trim();
            const amt = Number(m[2]);
            const line = `${who} Bought ${amt} SOL`;
            if (amt >= GIF_MIN_SOL && window.__lastShownLine !== line) {
              document.getElementById('latestText').textContent = line;
            const latest = document.getElementById('latest');
            latest.classList.remove('pulse');
            void latest.offsetWidth;
            latest.classList.add('pulse');
            try { particleBurst(); } catch(_) {}
              window.__lastShownLine = line;
            setTimeout(()=>{ document.getElementById('latestText').textContent='Waiting for buysâ€¦'; }, 3000);
            }
          }
        }
        if (latest) addRecent(latest); // UI only; do not persist or update counts to avoid duplicates
      } catch(_) {}

      // Render server-computed Top Buyers so all viewers see same state
      try {
        const top = (await fetchText('topbuyers.txt')).trim();
        const container = document.getElementById('topbuyers');
        if (top && top !== lastTopRaw) {
          const lines = top.split(/\r?\n/).filter(Boolean);
          let html = '<ul style=\"list-style:none; padding-left:10px; margin:0; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;\">';
          for (const line of lines) html += `<li style=\"padding:2px 0\">${line}</li>`;
          html += '</ul>';
          container.innerHTML = html;
          lastTopRaw = top;
        } else if (!top && !lastTopRaw) {
          container.textContent = 'â€”';
        }
      } catch(_) {
        const container = document.getElementById('topbuyers');
        if (!lastTopRaw) container.textContent = 'â€”';
      }

      // Show current top trader from JSON (address-ranked)
      try {
        const topJson = (await fetchText('topbuyers.json')).trim();
        if (topJson && topJson !== lastTopJsonRaw) {
          lastTopJsonRaw = topJson;
          const arr = JSON.parse(topJson);
          const top = Array.isArray(arr) && arr[0];
          const el = document.getElementById('topTraderLine');
          if (top && el) el.textContent = `Top Trader: ${(top.name || top.address)} â€” ${Number(top.totalSol||0).toFixed(4)} SOL (${top.count})`;
        }
      } catch(_) {}
    }, 2000);

    // Airdrop countdown + winners panel
    (function airdropBoot(){
      async function tick(){
        try {
          const txt = (await fetchText('airdrop_end.txt')).trim();
          const el = document.getElementById('airdropCountdown');
          const statusEl = document.getElementById('airdropStatus');
          const winnersEl = document.getElementById('winners');
          const end = Number(txt)||0;
          if (!(end>0)) { el.textContent = 'Airdrop: â€”'; statusEl.textContent = 'Airdrop: â€”'; return; }
          const rem = end - Date.now();
          if (rem <= 0) {
            el.textContent = 'Airdrop: ended';
            statusEl.textContent = 'Airdrop: ended';
            // try show winners if available
            try {
              const win = (await fetchText('airdrop_winners.json')).trim();
              if (win) {
                const data = JSON.parse(win);
                const list = (data && data.winners) || [];
                if (list.length) {
                  winnersEl.textContent = 'Airdrop Winners:\n' + list.map((w,i)=>`${i+1}. ${w.address} â€” ${Number(w.totalSol||0).toFixed(4)} SOL`).join('\n');
                  // winners effect
                  const airdropPanel = winnersEl.closest('.panel');
                  if (airdropPanel) { airdropPanel.classList.remove('win-animate'); void airdropPanel.offsetWidth; airdropPanel.classList.add('win-animate'); }
                }
              }
            } catch(_) {}
            return;
          }
          const s = Math.floor(rem/1000);
          const h = Math.floor(s/3600);
          const m = Math.floor((s%3600)/60);
          const sec = s%60;
          el.textContent = `Airdrop: ${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
          statusEl.textContent = el.textContent;
        } catch(_) {}
      }
      tick();
      setInterval(tick, 1000);

      // Manual end button
      async function forceAirdropRefresh(){
        try {
          const t = (await fetchText('airdrop_end.txt')).trim();
          const el = document.getElementById('airdropCountdown');
          el.textContent = t ? el.textContent : 'Airdrop: â€”';
          // also try to render winners immediately if available
          const win = (await fetchText('airdrop_winners.json')).trim();
          if (win) {
            const data = JSON.parse(win);
            const list = (data && data.winners) || [];
            if (list.length) {
              const winnersEl = document.getElementById('winners');
              winnersEl.textContent = 'Airdrop Winners:\n' + list.map((w,i)=>`${i+1}. ${w.address} â€” ${Number(w.totalSol||0).toFixed(4)} SOL`).join('\n');
            }
          }
        } catch(_) {}
      }

      document.getElementById('airdropNowBtn').addEventListener('click', async (e) => {
        const btn = e.currentTarget;
        const original = btn.textContent;
        btn.disabled = true; btn.textContent = 'Endingâ€¦';
        try {
          const res = await fetch('/airdrop/now', { method: 'POST', headers: { 'cache-control':'no-cache' } });
          if (!res.ok) throw new Error('Request failed');
        } catch (_) {
          try { await fetch('/airdrop/now', { method: 'GET' }); } catch (_) {}
        } finally {
          await new Promise(r=>setTimeout(r, 250));
          await forceAirdropRefresh();
          // flash the airdrop panel for feedback
          try {
            const panel = btn.closest('.panel');
            panel.classList.remove('airdrop-flash'); void panel.offsetWidth; panel.classList.add('airdrop-flash');
          } catch(_) {}
          setTimeout(()=>{ btn.disabled = false; btn.textContent = original; }, 800);
        }
      });
    })();

    // Disable click-to-open details on rendered list (server lines have no data-name)

    // (Pause button removed for viewer experience)
  </script>
</body>
</html>


